#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "ch.h"
#include "hal.h"
#include "memory_protection.h"
#include <main.h>
#include "leds.h"
#include "spi_comm.h"
#include "sensors/proximity.h"
#include "sensors/VL53L0X/VL53L0X.h"
#include "motors.h"

messagebus_t bus;
MUTEX_DECL(bus_lock);
CONDVAR_DECL(bus_condvar);

#define FRONT_THRESHOLD 5  // mm
#define PROX_THRESHOLD 600  // Proximity sensor threshold 600
#define TURN_SPEED 600  	 // Speed for turning
#define MOVE_SPEED 800  	 // Speed for moving forward
#define TURN_TIME 300       // amount of time for turning

void turn_randomly(void) {
    int random_turn = rand() % 2;
    int random_time = rand() % 501; // 0 = left, 1 = right
    if (random_turn == 0) {
   	 left_motor_set_speed(-TURN_SPEED);
   	 right_motor_set_speed(TURN_SPEED);
    } else {
   	 left_motor_set_speed(TURN_SPEED);
   	 right_motor_set_speed(-TURN_SPEED);
    }
    chThdSleepMilliseconds(random_time); // Short turn duration
}

int main(void) {
    halInit();
    chSysInit();
    mpu_init();

    // Initialize Sensors & Motors
    messagebus_init(&bus, &bus_lock, &bus_condvar);
    proximity_start(0);
    calibrate_ir();
    VL53L0X_start();
    clear_leds();
    spi_comm_start();
    motors_init();

    while (1) {
   	 int front_dist = VL53L0X_get_dist_mm();
   	 int prox_left = get_calibrated_prox(6);
   	 int prox_right = get_calibrated_prox(1);
   	 int prox_front_left = get_calibrated_prox(7);
   	 int prox_front_right = get_calibrated_prox(0);

   	 // Robot Surrounded at the front
   	 if (front_dist < FRONT_THRESHOLD && prox_front_left < PROX_THRESHOLD && prox_front_right < PROX_THRESHOLD && prox_left < PROX_THRESHOLD && prox_right < PROX_THRESHOLD) {
   		 turn_randomly();
   	 }
   	 // Side obstacles detected - adjust path
   	 else if (prox_left < PROX_THRESHOLD) {
   		 left_motor_set_speed(TURN_SPEED);
   		 right_motor_set_speed(-TURN_SPEED);
   		 chThdSleepMilliseconds(TURN_TIME);
   	 }
   	 else if (prox_right < PROX_THRESHOLD) {
   		 left_motor_set_speed(-TURN_SPEED);
   		 right_motor_set_speed(TURN_SPEED);
   		 chThdSleepMilliseconds(TURN_TIME);
   	 }
   	 // Default forward movement
   	 else {
   		 left_motor_set_speed(MOVE_SPEED);
   		 right_motor_set_speed(MOVE_SPEED);
   	 }
    }
}

#define STACK_CHK_GUARD 0xe2dee396
uintptr_t __stack_chk_guard = STACK_CHK_GUARD;

void __stack_chk_fail(void) {
    chSysHalt("Stack smashing detected");
}





// Include standard libraries
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Include ChibiOS headers
#include "ch.h"
#include "hal.h"
#include "memory_protection.h"

// Include hardware and sensor-specific libraries
#include "leds.h"
#include "spi_comm.h"
#include "sensors/proximity.h"
#include "sensors/VLS3LOX/VLS3LOX.h"
#include "motors.h"
#include "selector.h"
#include "epucklx/uart/e_uart_char.h"
#include "serial_comm.h"

// Thresholds and constants for behavior logic
#define PROX_THRESHOLD 150       // Minimum proximity reading to trigger interest
#define TARGET_DIST_MIN 20       // Minimum desired distance to object (mm)
#define TARGET_DIST_MAX 50       // Maximum desired distance to object (mm)
#define BASE_SPEED 400           // Default motor speed
#define MAX_TURN_SPEED 800       // Maximum speed difference when turning
#define MIN_TURN_SPEED 400       // Minimum speed difference when turning
#define SENSOR_COUNT 8           // Number of proximity sensors

// Declare message bus for inter-thread communication (ChibiOS feature)
messagebus_t bus;
MUTEX_DECL(bus_lock);
CONDVAR_DECL(bus_condvar);

// State machine for behavior logic
typedef enum { SEARCH, APPROACH, CHASE } State;

// Convert sensor index to approximate angle in degrees
float estimate_angle(int max_sensor) {
    float angles[SENSOR_COUNT] = {0, 45, 90, 135, 180, 225, 270, 315};
    return angles[max_sensor];
}

// Main object-following behavior function
void follow_object(void) {
    static State state = SEARCH; // Start in SEARCH state

    // Arrays to hold sensor readings
    int prox[SENSOR_COUNT], max_prox = 0, max_sensor = 0;

    // Read proximity sensors and find the one with the highest value
    for (int i = 0; i < SENSOR_COUNT; i++) {
        prox[i] = get_calibrated_prox(i);
        if (prox[i] > max_prox) {
            max_prox = prox[i];
            max_sensor = i;
        }
    }

    // Read distance from Time-of-Flight sensor
    uint16_t dist = VLS3LOX_get_dist_mm();

    // Use selector to vary base speed (for easy tuning)
    int selector = get_selector();
    int base_speed = BASE_SPEED + (selector * 25);

    // Get angle from sensor index
    float angle = estimate_angle(max_sensor);

    // Determine how much to turn (0 if object is directly ahead)
    float turn_factor = fabs(angle - 180) / 180;
    int turn_speed = MIN_TURN_SPEED + (MAX_TURN_SPEED - MIN_TURN_SPEED) * turn_factor;

    // Print debug data to UART
    char str[100];
    int str_length = sprintf(str, "Prox: %d, Dist: %d, State: %d\n", max_prox, dist, state);
    e_send_uart1_char(str, str_length);

    // State machine to control robot behavior
    switch (state) {
        case SEARCH:
            set_body_led(0); // Body LED off
            set_rgb_led(LED2, 10, 0, 0); // Red LED
            if (max_prox >= PROX_THRESHOLD)
                state = APPROACH;
            else {
                // Rotate to scan environment
                left_motor_set_speed(MIN_TURN_SPEED);
                right_motor_set_speed(-MIN_TURN_SPEED);
            }
            break;

        case APPROACH:
            set_body_led(1); // Body LED on
            set_rgb_led(LED2, 0, 10, 0); // Green LED
            if (dist <= TARGET_DIST_MAX && dist >= TARGET_DIST_MIN)
                state = CHASE;
            else if (max_prox < PROX_THRESHOLD)
                state = SEARCH;
            else {
                // Adjust motor speeds to turn toward the object
                int left_speed = base_speed - (angle > 180 ? turn_speed : 0);
                int right_speed = base_speed - (angle < 180 ? turn_speed : 0);
                left_motor_set_speed(left_speed);
                right_motor_set_speed(right_speed);
            }
            break;

        case CHASE:
            set_body_led(1); 
            set_rgb_led(LED2, 0, 0, 10); // Blue LED
            if (max_prox < PROX_THRESHOLD || dist > TARGET_DIST_MAX)
                state = SEARCH;
            else {
                // Speed adjustment based on distance to object
                int speed_adjust = (dist < TARGET_DIST_MIN) ? base_speed * 0.8 :
                                   (dist > TARGET_DIST_MAX) ? base_speed * 1.5 :
                                   base_speed;
                int left_speed = speed_adjust - (angle > 180 ? turn_speed : 0);
                int right_speed = speed_adjust - (angle < 180 ? turn_speed : 0);
                left_motor_set_speed(left_speed);
                right_motor_set_speed(right_speed);
            }
            break;
    }
}

// Main program entry point
int main(void) {
    halInit();                     // Hardware abstraction layer init
    chSysInit();                   // ChibiOS kernel init
    mpu_init();                    // Memory protection init
    messagebus_init(&bus, &bus_lock, &bus_condvar); // Init message bus

    proximity_start();             // Start proximity sensor
    calibrate_ir();                // Calibrate IR proximity sensors
    VLS3LOX_start();               // Start Time-of-Flight sensor
    clear_leds();                  // Turn off LEDs
    spi_comm_start();             // Start SPI communication
    motors_init();                 // Initialize motors
    serial_start();                // Start serial communication

    // Main control loop
    while (1) {
        follow_object();           // Run behavior function
        chThdSleepMilliseconds(50); // Small delay to prevent CPU overuse
    }
}

// Stack smashing protection (ChibiOS-specific)
#define STACK_CHK_GUARD 0xe2dee396
uintptr_t __stack_chk_guard = STACK_CHK_GUARD;
void __stack_chk_fail(void) {
    chSysHalt("Stack smashing detected");
}
